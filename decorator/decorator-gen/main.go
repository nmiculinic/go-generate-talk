package main


import (
	"flag"
	"text/template"
	"go/token"
	"go/printer"
	"go/parser"
	"log"
	"os"
	"fmt"
	"go/ast"
	"strings"
	_ "go/format"
	"bytes"
	"github.com/Masterminds/sprig"
	"go/format"
)

type TemplateValues struct {
	Name string
	Results []string
	Args []string
}

const tmp = `
func {{ .Name }}Chan(in chan<- {{.Name}}Req, out <-chan {{ .Name }}Resp) {
	for it := range in {
		{{ .Results | join "," }} := {{ .Name }}(
		{{- range $index, $element := .Args }}
			it.{{ $element }},
		{{- end }}
		)	
		out <- {{ .Name }}Resp{ {{- .Results | join "," -}} }
	}
}
`

func main() {
	in := flag.String("in","", "input file")
	out := flag.String("out","", "out")
	quiet := flag.Bool("q",false, "quiet mode")
	flag.Parse()
	if *in == ""  || *out == "" {
		flag.Usage()
		return
	}

	t, err := template.New("xx").Funcs(sprig.TxtFuncMap()).Parse(tmp)
	if err != nil {
		log.Fatal(err)
	}

	fs := token.NewFileSet()
	f, err := parser.ParseFile(fs, *in, nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err)
	}

	imports := make(map[string]*ast.ImportSpec, len(f.Imports))
	for _, x := range f.Imports {
		imports[x.Name.Name] = x
	}
	usedImports := make(map[string]bool)
	elems := make([]string, 0)

	for _, decl := range f.Decls {
		switch decl.(type) {
		case *ast.FuncDecl:
			decl := decl.(*ast.FuncDecl)  // For better autocompletion
			if decl.Doc == nil {
				continue
			}
			for _, comm := range decl.Doc.List {
				if strings.HasPrefix(comm.Text, "//@decorate:chan") {
					reqStructName := decl.Name.Name + "Req"
					respStructName := decl.Name.Name + "Resp"
					out := &bytes.Buffer{}
					reqStruct, reqElems := makeStruct(decl.Type.Params,reqStructName, fs, usedImports)
					respStruct, respElems := makeStruct(decl.Type.Results,respStructName, fs, usedImports)

					fmt.Fprintln(out, reqStruct)
					fmt.Fprintln(out, respStruct)
					t.Execute(out, TemplateValues{
						Name:decl.Name.Name,
						Results:respElems,
						Args:reqElems,
					})
					elems = append(elems, out.String())
					if !*quiet {
						log.Println("generating func for", decl.Name.Name)
					}
				}
			}
		default:
		}

	}

	// Final printing
	b := &bytes.Buffer{}
	fmt.Fprintf(b, "// Code generated by decorator-gen; DO NOT EDIT.\npackage ")
	printer.Fprint(b, fs, f.Name)
	fmt.Fprintln(b)

	fmt.Fprintln(b, "import (")
	for imp := range usedImports {
		printer.Fprint(b, fs, imports[imp])
		fmt.Fprintln(b)
	}
	fmt.Fprintln(b, ")")
	for _, x := range elems {
		fmt.Fprintln(b, x)
	}

	// Runing through go-fmt
	s, err := format.Source(b.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	outFile, err := os.Create(*out)
	if err != nil {
		log.Fatal(err)
	}
	if _, err := outFile.Write(s); err != nil {
		outFile.Close()
		log.Fatal(err)
	}
	if err := outFile.Close(); err != nil {
		log.Fatal(err)
	}
}


// makeStruct created struct with all required fields in the FieldList
func makeStruct(fields *ast.FieldList, structName string, fs *token.FileSet, usedImports map[string]bool) (string, []string){
	s:= &bytes.Buffer{}
	fmt.Fprintf(s, "type %s struct {\n", structName)
	ListNames := make([]string, 0, len(fields.List))
	for i, inp := range fields.List {
		names := []string{}
		if len(inp.Names) == 0 {
			names = append(names, fmt.Sprintf("element%d", i))
		}
		for _, name := range inp.Names {
			names = append(names, name.Name)
		}
		ListNames = append(ListNames, names...)
		fmt.Fprintf(s, "%s ", strings.Join(names, ","))
		tBuff := &bytes.Buffer{}
		printer.Fprint(tBuff, fs, inp.Type)
		typeStr := tBuff.String()
		fmt.Fprintln(s, typeStr)
		if strings.Contains(typeStr, ".") {
			usedImports[strings.Split(typeStr, ".")[0]] = true
		}
	}
	fmt.Fprintln(s, "}")
	return s.String(), ListNames
}
