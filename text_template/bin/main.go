package main

import (
	"bytes"
	"fmt"
	"log"
	"os"
	"text/template"
)

const tml = `
type Empty{{ .Name }} struct{}

func (f *Empty{{ .Name }}) Filter(in map[string]{{ .T }}) map[string]{{ .T }} {
	return in
}

type Compose{{ .Name }} []{{ .TInterfaceName }}

func (f *Compose{{ .Name }}) Filter(in map[string]{{ .T }}) map[string]{{ .T }} {
	out := in
	for _, filter := range f {
		out = filter(out)
	}
	return out
}

`

func main() {
	if !(len(os.Args) >= 2 && os.Args[len(os.Args)-2] == "--") {
		log.Fatal("no source file defined")
	}

	sourceFile := os.Args[len(os.Args)-1]
	t, err := template.New("xx").Parse(tml)
	if err != nil {
		log.Fatal(err)
	}
	b := &bytes.Buffer{}
	fmt.Fprintf(b,
		`// Code generated by bin from %s. DO NOT EDIT.

package template_text
`,
		sourceFile,
	)
	for _, values := range []struct {
		Name           string
		T              string
		TInterfaceName string
	}{
		{
			Name:           "Int",
			T:              "int",
			TInterfaceName: "FInt",
		},
		{
			Name:           "String",
			T:              "string",
			TInterfaceName: "FString",
		},
	} {
		if err := t.Execute(b, values); err != nil {
			log.Fatal(err)
		}
	}
	f, err := os.Create("./" + sourceFile[:len(sourceFile)-3] + ".bin.go")
	if err != nil {
		log.Fatal(err)
	}
	if _, err := fmt.Fprintln(f, b.String()); err != nil {
		log.Fatal(err)
	}
	if err := f.Close(); err != nil {
		log.Fatal(err)
	}
}
